---
layout: post
title: "Trapdoor author writeup"
categories: learning
author: s1nn105 
---
A little contribution to revive the KITCTF blog.
## GPNCTF Trapdoor
For GPNCTF I wrote an crypto challenge. It was called trapdoor and at least I thought about using advanced math to solve it.
This is not your typical  writeup where I show my code and tell you why you are stupid and should start using sage (you should but thats not the point).
I am going to explain a bit of the ideas and the math I looked at when writing the challenge, and when solving it myself. Be warned This wont be the most efficient or simplest solve for sure.
Also I stopped when it worked and dig not any further so there might be some flaws and oversights that just work out somehow.
The for now relevant part looked like:
The challenge looked as follows:
```py

    flagFieldElem = a^expo
    #all output below here is intended for solve
    print(f"Field Base:{K.base().order()}")
    print(f"Field Expo:{log(K.order(),K.base().order())}")
    print(f"NumElems:{K.cardinality()}")
    print(f"gen:{K.modulus()}")
    minpoly = flagFieldElem.minpoly()
    print(f"Hash is:{minpoly(EVAL_VALUE)}")```
```
The flag was encoded as integer and a group element was generated by computing $$a^{flag}$$ in a Galios Field. 
But what is an galios field, how does it work, and how is it connected to polynomials. 

### Why more math 
Obviously because it is fun. Jokes a aside, you probably know that $$^{\mathbb{Z}}/_{p\mathbb{Z}}$$ is a field if p is a prime. A field in this context means that for all elements (except 0) there is not only an additive but also an multiplicative inverse. And you might have heard you professor or your friends talking about the fact that there are finite fields for each power of a prime. But if you tried construciting such a field with say 25 elements you failed (hopefully), because you just could not find "the right way" to  define your operations: 
Consider "$$^{\mathbb{Z}}/_{2\mathbb{Z}} \times ^{\mathbb{Z}}/_{5\mathbb{Z}}$$. What would be your $$\mathbb{1}$$ element? $$(1,0)$$ or $$(1,1)$$, both won't work (if you dont believe me try to find where, this is a great exercise).

#### Polynomials for the win 
We wont worry  to much about how we can construct such fields in detail. The only thing we need to know for now is that we construct such fields L as  extensions of other fields K. (Written $$L \ K $$)
Meaning we start at an known K  field (e.g GF(5)) and then add new elements,for the sake of simplicity say we only add one element $$a$$, more formal we add elements and then consider the smallest field containing the old field and the elements we newly added.
The incredibly useful thing (at least for computer people) is that 
the newly build field is (at least in our case) then equivalent to $$^{K[X]}/_{(m_a)}$$ where $$m_a \in K[X]$$ is the minimal polynomial of $$a$$ in K[X]. The latter just means that all coefficients of $$m_a$$ are in K (and that it is normed but we dont care about that) and $$m_a(a)=0$$  and the degree of m is minimal.
Cool now we have a way to display such finite fields as polynomials modulu another polynomial.

### How is this related to the challenge ?? 
_Being very "wrong" and impercise for a moment: The thing is we have seen that field extensions are just a fancy way for talking about polynomials and long division. Polynomials are vector spaces and some vector space things can therefore also been done one field extensions_

Consider the map for an $$a \in L$$:
$$L \rightarrow L \\ 
x \mapsto  x \cdot a $$
and consider the determinant of this map this is called the field map $$N_{L\\K}: L \rightarrow k, a \mapsto N_{L\\K}(a)$$
This map has many cool properties like being multiplicative (meaning a homorphism of the unit groups) and if you consider a element $$a \in L$$ with $$m_a = X^n \cdot \alpha_n + ... + \alpha_0$$ then
$$N_{L\\K}(a) = \pm \alpha_0$$ the sign depending on the degree of the extension and the degree of the minimal polynomial. This was one step I had in mind when building the challenge.
Using this and the fact that we have multiple instances we can  decrease the key space enough to iterate the remaining possiblities to find the flag.

### Iterating the possible values
Galios Theory tells us even more (this was the inital starting point for this challenge...): 
$$N_{L\\K}(a) = \Pi_{\sigma \in GAL(L\\K)} \sigma(a)$$. What galios groups are would go to far but for finite fields we know that they are generated by Frobenius homomorphisms. This means that they are generated by $$ x \mapsto x^p$$ with p being the characteristic. Thus the norm boils down to $$N_{L\\K}(a) = a^\alpha$$ for the right $$\alpha$$ which can simply be calculated or just be looked up on e.g. wikipedia. Thinking about this a bit longer (you want to get yourself familiar with the concept of primitiv roots) we find out that solutions to equations of the from $$y = x^\alpha$$ can be altered by the unit group. More formally, if $$\omega$$ is a solution to the equation above and $$\phi^\alpha=1$$ then $$\omega \cdot \phi$$ is indeed also an solution. Personally I am not totally sure  about the number of "nontrivial" solutions or any other detail you might want to look this  up for peace of mind.

If we now go back to the challenge we get that for one instance the possible values for the flag form a line. If we took two instances and they would intersect we would have found the flag. Sadly they dont (again I dont remember that part of the solve that well so it is left as an exercise).
But this essentially means we can combine multiple instances to get an  iterator that skips more elements. This construction is bascially a kind of chinese remainder theorem.
### Related resources 
If you want to know more about galios theory consider visting a university course if you have the chance otherwise there are many great online resources and books, like [this](https://www.maths.ed.ac.uk/~tl/gt/gt.pdf), but probably you want to start at an introduction to groups and algebra in general first.
Somewhere here should be a link to the challenge files
